{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Install Color This guide will explain how to install the colord and colorcli entrypoints onto your system. With these installed on a server, you can participate in the mainnet as either a Full Node or a Validator Install Go Install go by following the official docs . Remember to set your $GOPATH and $PATH environment variables, for example: mkdir -p $HOME/go/bin echo \"export GOPATH=$HOME/go\" >> ~/.bash_profile echo \"export PATH=\\$PATH:\\$GOPATH/bin\" >> ~/.bash_profile source ~/.bash_profile ::: tip Go 1.12+ is required. ::: Install the binaries Next, let's install the latest version of Color. mkdir -p $GOPATH/src/github.com/cosmos cd $GOPATH/src/github.com/cosmos git clone https://github.com/usmanfazil/colorproject cd colorproject && make install NOTE : If you have issues at this step, please check that you have the latest stable version of GO installed. That will install the colord and colorcli binaries. Verify that everything is OK: $ colord version --long $ colorcli version --long colorcli for instance should output something similar to: name: color servername: colord clientname: colorcli build tags: netgo ledger go version go1.12 linux/amd64 Build Tags Build tags indicate special features that have been enabled in the binary. Build Tag Description netgo Name resolution will use pure Go code ledger Ledger devices are supported (hardware wallets) Next Now you can create you own testnet","title":"Installation"},{"location":"#install-color","text":"This guide will explain how to install the colord and colorcli entrypoints onto your system. With these installed on a server, you can participate in the mainnet as either a Full Node or a Validator","title":"Install Color"},{"location":"#install-go","text":"Install go by following the official docs . Remember to set your $GOPATH and $PATH environment variables, for example: mkdir -p $HOME/go/bin echo \"export GOPATH=$HOME/go\" >> ~/.bash_profile echo \"export PATH=\\$PATH:\\$GOPATH/bin\" >> ~/.bash_profile source ~/.bash_profile ::: tip Go 1.12+ is required. :::","title":"Install Go"},{"location":"#install-the-binaries","text":"Next, let's install the latest version of Color. mkdir -p $GOPATH/src/github.com/cosmos cd $GOPATH/src/github.com/cosmos git clone https://github.com/usmanfazil/colorproject cd colorproject && make install NOTE : If you have issues at this step, please check that you have the latest stable version of GO installed. That will install the colord and colorcli binaries. Verify that everything is OK: $ colord version --long $ colorcli version --long colorcli for instance should output something similar to: name: color servername: colord clientname: colorcli build tags: netgo ledger go version go1.12 linux/amd64","title":"Install the binaries"},{"location":"#build-tags","text":"Build tags indicate special features that have been enabled in the binary. Build Tag Description netgo Name resolution will use pure Go code ledger Ledger devices are supported (hardware wallets)","title":"Build Tags"},{"location":"#next","text":"Now you can create you own testnet","title":"Next"},{"location":"ChangeMonikerLogo/","text":"Change Default Moniker logo To change default Moniker logo you must have account on keybase. Perform the following setups to change logo. Create Account on Keybase Visit base.io/ create new account on it using sign up process. Install keybase application on your linux machine. Run following command to generate keybase pgp keybase pgp gen this will generate add new pgp key in your account Updating your validator Now you have to update you validator with new pgp key you generated. Run the following command to edit validator colorcli stake edit-validator --identity=\"DA2034902BBED118\" -\u2013from=rnssol","title":"ChangeValidatorLogo"},{"location":"ChangeMonikerLogo/#change-default-moniker-logo","text":"To change default Moniker logo you must have account on keybase. Perform the following setups to change logo.","title":"Change Default Moniker logo"},{"location":"ChangeMonikerLogo/#create-account-on-keybase","text":"Visit base.io/ create new account on it using sign up process. Install keybase application on your linux machine. Run following command to generate keybase pgp keybase pgp gen this will generate add new pgp key in your account","title":"Create Account on Keybase"},{"location":"ChangeMonikerLogo/#updating-your-validator","text":"Now you have to update you validator with new pgp key you generated. Run the following command to edit validator colorcli stake edit-validator --identity=\"DA2034902BBED118\" -\u2013from=rnssol","title":"Updating your validator"},{"location":"Explorer_setup/","text":"Color Explorer Block Explorer for Color How to run The Color Explorer Clone the color explorer github repo. https://github.com/UsmanFazil/explorer Copy default_settings.json to settings.json . Update chain-id. Update the RPC URL. Update the LCD URL. Update Bech32 address prefixes. Update genesis file location. Run in local meteor npm install meteor update meteor --settings settings.json Run in production ./build.sh It will create a packaged Node JS tarball at ../output . Deploy that packaged Node JS project with process manager like forever or Phusion Passenger .","title":"Explorer"},{"location":"Explorer_setup/#color-explorer","text":"Block Explorer for Color","title":"Color Explorer"},{"location":"Explorer_setup/#how-to-run-the-color-explorer","text":"Clone the color explorer github repo. https://github.com/UsmanFazil/explorer Copy default_settings.json to settings.json . Update chain-id. Update the RPC URL. Update the LCD URL. Update Bech32 address prefixes. Update genesis file location.","title":"How to run The Color Explorer"},{"location":"Explorer_setup/#run-in-local","text":"meteor npm install meteor update meteor --settings settings.json","title":"Run in local"},{"location":"Explorer_setup/#run-in-production","text":"./build.sh It will create a packaged Node JS tarball at ../output . Deploy that packaged Node JS project with process manager like forever or Phusion Passenger .","title":"Run in production"},{"location":"colorcli/","text":"Color Client Color CLI colorcli is the tool that enables you to interact with the node that runs on the Color network, whether you run it yourself or not. Let us set it up properly. In order to install it, follow the installation procedure . Setting up colorcli The main command used to set up colorcli is the following: colorcli config <flag> <value> It allows you to set a default value for each given flag. First, set up the address of the full-node you want to connect to: colorcli config node <host>:<port # example: colorcli config node https://77.87.106.33:26657 If you run your own full-node, just use tcp://localhost:26657 as the address. Then, let us set the default value of the --trust-node flag: colorcli config trust-node true # Set to true if you trust the full-node you are connecting to, false otherwise Finally, let us set the chain-id of the blockchain we want to interact with: colorcli config chain-id <testchain> Keys Key Types There are three types of key representations that are used: cosmos Derived from account keys generated by colorcli keys add Used to receive funds e.g. cosmos15h6vd5f0wqps26zjlwrc6chah08ryu4hzzdwhc cosmosvaloper Used to associate a validator to it's operator Used to invoke staking commands e.g. cosmosvaloper1carzvgq3e6y3z5kz5y6gxp3wpy3qdrv928vyah cosmospub Derived from account keys generated by colorcli keys add e.g. cosmospub1zcjduc3q7fu03jnlu2xpl75s2nkt7krm6grh4cc5aqth73v0zwmea25wj2hsqhlqzm cosmosvalconspub Generated when the node is created with colord init . Get this value with colord tendermint show-validator e.g. cosmosvalconspub1zcjduepq0ms2738680y72v44tfyqm3c9ppduku8fs6sr73fx7m666sjztznqzp2emf Generate Keys You'll need an account private and public key pair (a.k.a. sk, pk respectively) to be able to receive funds, send txs, bond tx, etc. To generate a new secp256k1 key: colorcli keys add <account_name> Next, you will have to create a passphrase to protect the key on disk. The output of the above command will contain a seed phrase . It is recommended to save the seed phrase in a safe place so that in case you forget the password, you could eventually regenerate the key from the seed phrase with the following command: colorcli keys add --recover If you check your private keys, you'll now see <account_name> : colorcli keys show <account_name> View the validator operator's address via: colorcli keys show <account_name> --bech=val You can see all your available keys by typing: colorcli keys list View the validator pubkey for your node by typing: colord tendermint show-validator Note that this is the Tendermint signing key, not the operator key you will use in delegation transactions. ::: danger Warning We strongly recommend NOT using the same passphrase for multiple keys. ::: Generate Multisig Public Keys You can generate and print a multisig public key by typing: colorcli keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name K is the minimum number of private keys that must have signed the transactions that carry the public key's address as signer. The --multisig flag must contain the name of public keys that will be combined into a public key that will be generated and stored as new_key_name in the local database. All names supplied through --multisig must already exist in the local database. Unless the flag --nosort is set, the order in which the keys are supplied on the command line does not matter, i.e. the following commands generate two identical keys: colorcli keys add --multisig=foo,bar,baz --multisig-threshold=2 multisig_address colorcli keys add --multisig=baz,foo,bar --multisig-threshold=2 multisig_address Multisig addresses can also be generated on-the-fly and printed through the which command: colorcli keys show --multisig-threshold K name1 name2 name3 [...] For more information regarding how to generate, sign and broadcast transactions with a multi signature account see Multisig Transactions . Tx Broadcasting When broadcasting transactions, colorcli accepts a --broadcast-mode flag. This flag can have a value of sync (default), async , or block , where sync makes the client return a CheckTx response, async makes the client return immediately, and block makes the client wait for the tx to be committed (or timing out). It is important to note that the block mode should not be used in most circumstances. This is because broadcasting can timeout but the tx may still be included in a block. This can result in many undesirable situations. Therefor, it is best to use sync or async and query by tx hash to determine when the tx is included in a block. Fees & Gas Each transaction may either supply fees or gas prices, but not both. Validator's have a minimum gas price (multi-denom) configuration and they use this value when when determining if they should include the transaction in a block during CheckTx , where gasPrices >= minGasPrices . Note, your transaction must supply fees that are greater than or equal to any of the denominations the validator requires. Note : With such a mechanism in place, validators may start to prioritize txs by gasPrice in the mempool, so providing higher fees or gas prices may yield higher tx priority. e.g. colorcli tx send ... --fees=50000color or colorcli tx send ... --gas-prices=0.025color Account Query Account Balance After receiving tokens to your address, you can view your account's balance by typing: colorcli query account <account_address> ::: warning Note When you query an account balance with zero tokens, you will get this error: No account with address <account_address> was found in the state. This can also happen if you fund the account before your node has fully synced with the chain. These are both normal. ::: Send Tokens The following command could be used to send coins from one account to another: colorcli tx send <sender_key_name_or_address> <recipient_address> 10stake \\ --chain-id=<chain_id> ::: warning Note The amount argument accepts the format <value|coin_name> . ::: ::: tip Note You may want to cap the maximum gas that can be consumed by the transaction via the --gas flag. If you pass --gas=auto , the gas supply will be automatically estimated before executing the transaction. Gas estimate might be inaccurate as state changes could occur in between the end of the simulation and the actual execution of a transaction, thus an adjustment is applied on top of the original estimate in order to ensure the transaction is broadcasted successfully. The adjustment can be controlled via the --gas-adjustment flag, whose default value is 1.0. ::: Now, view the updated balances of the origin and destination accounts: colorcli query account <account_address> colorcli query account <destination_address> You can also check your balance at a given block by using the --block flag: colorcli query account <account_address> --block=<block_height> You can simulate a transaction without actually broadcasting it by appending the --dry-run flag to the command line: colorcli tx send <sender_key_name_or_address> <destination_account_address> 10stake \\ --chain-id=<chain_id> \\ --dry-run Furthermore, you can build a transaction and print its JSON format to STDOUT by appending --generate-only to the list of the command line arguments: colorcli tx send <sender_address> <recipient_address> 10stake \\ --chain-id=<chain_id> \\ --generate-only > unsignedSendTx.json colorcli tx sign \\ --chain-id=<chain_id> \\ --from=<key_name> \\ unsignedSendTx.json > signedSendTx.json ::: tip Note The --generate-only flag prevents colorcli from accessing the local keybase. Thus when such flag is supplied <sender_key_name_or_address> must be an address. ::: You can validate the transaction's signatures by typing the following: colorcli tx sign --validate-signatures signedSendTx.json You can broadcast the signed transaction to a node by providing the JSON file to the following command: colorcli tx broadcast --node=<node> signedSendTx.json Query Transactions Matching a Set of Tags You can use the transaction search command to query for transactions that match a specific set of tags , which are added on every transaction. Each tag is conformed by a key-value pair in the form of <tag>:<value> . Tags can also be combined to query for a more specific result using the & symbol. The command for querying transactions using a tag is the following: colorcli query txs --tags='<tag>:<value>' And for using multiple tags : colorcli query txs --tags='<tag1>:<value1>&<tag2>:<value2>' The pagination is supported as well via page and limit : colorcli query txs --tags='<tag>:<value>' --page=1 --limit=20 Matching a Transaction's Hash You can also query a single transaction by its hash using the following command: colorcli query tx [hash] Slashing Unjailing To unjail your jailed validator colorcli tx slashing unjail --from <validator-operator-addr> Signing Info To retrieve a validator's signing info: colorcli query slashing signing-info <validator-pubkey> Query Parameters You can get the current slashing parameters via: colorcli query slashing params Minting You can query for the minting/inflation parameters via: colorcli query minting params To query for the current inflation value: colorcli query minting inflation To query for the current annual provisions value: colorcli query minting annual-provisions Query Validators You can query the list of all validators of a specific chain: colorcli query staking validators If you want to get the information of a single validator you can check it with: colorcli query staking validator <account_cosmosval> Bond Tokens colorcli tx staking delegate \\ --amount=10000000stake \\ --validator=<validator> \\ --from=<key_name> \\ --chain-id=<chain_id> <validator> is the operator address of the validator to which you intend to delegate. If you are running a local testnet, you can find this with: colorcli keys show [name] --bech val where [name] is the name of the key you specified when you initialized colord . While tokens are bonded, they are pooled with all the other bonded tokens in the network. Validators and delegators obtain a percentage of shares that equal their stake in this pool. Query Delegations Once submitted a delegation to a validator, you can see it's information by using the following command: colorcli query staking delegation <delegator_addr> <validator_addr> Or if you want to check all your current delegations with disctinct validators: colorcli query staking delegations <delegator_addr> Unbond Tokens If for any reason the validator misbehaves, or you just want to unbond a certain amount of tokens, use this following command. colorcli tx staking unbond \\ <validator_addr> \\ 10stake \\ --from=<key_name> \\ --chain-id=<chain_id> The unbonding will be automatically completed when the unbonding period has passed. Query Unbonding-Delegations Once you begin an unbonding-delegation, you can see it's information by using the following command: colorcli query staking unbonding-delegation <delegator_addr> <validator_addr> Or if you want to check all your current unbonding-delegations with disctinct validators: colorcli query staking unbonding-delegations <account_cosmos> Additionally, as you can get all the unbonding-delegations from a particular validator: colorcli query staking unbonding-delegations-from <account_cosmosval> Redelegate Tokens A redelegation is a type delegation that allows you to bond illiquid tokens from one validator to another: colorcli tx staking redelegate \\ <src-validator-operator-addr> \\ <dst-validator-operator-addr> \\ 10stake \\ --from=<key_name> \\ --chain-id=<chain_id> Here you can also redelegate a specific shares-amount or a shares-fraction with the corresponding flags. The redelegation will be automatically completed when the unbonding period has passed. Query Redelegations Once you begin an redelegation, you can see it's information by using the following command: colorcli query staking redelegation <delegator_addr> <src_val_addr> <dst_val_addr> Or if you want to check all your current unbonding-delegations with distinct validators: colorcli query staking redelegations <account_cosmos> Additionally, as you can get all the outgoing redelegations from a particular validator: colorcli query staking redelegations-from <account_cosmosval> Query Parameters Parameters define high level settings for staking. You can get the current values by using: colorcli query staking params With the above command you will get the values for: Unbonding time Maximum numbers of validators Coin denomination for staking All these values will be subject to updates though a governance process by ParameterChange proposals. Query Pool A staking Pool defines the dynamic parameters of the current state. You can query them with the following command: colorcli query staking pool With the pool command you will get the values for: Not-bonded and bonded tokens Token supply Current annual inflation and the block in which the last inflation was processed Last recorded bonded shares Query Delegations To Validator You can also query all of the delegations to a particular validator: colorcli query delegations-to <account_cosmosval> Governance Governance is the process from which users in the Color Platform can come to consensus on software upgrades, parameters of the mainnet or signaling mechanisms through text proposals. This is done through voting on proposals, which will be submitted by color holders on the mainnet. Some considerations about the voting process: Voting is done by bonded color holders on a 1 bonded color 1 vote basis Delegators inherit the vote of their validator if they don't vote Votes are tallied at the end of the voting period (2 weeks on mainnet) where each address can vote multiple times to update its Option value (paying the transaction fee each time), only the most recently cast vote will count as valid Voters can choose between options Yes , No , NoWithVeto and Abstain At the end of the voting period, a proposal is accepted iff: (YesVotes / (YesVotes+NoVotes+NoWithVetoVotes)) > 1/2 (NoWithVetoVotes / (YesVotes+NoVotes+NoWithVetoVotes)) < 1/3 ((YesVotes+NoVotes+NoWithVetoVotes) / totalBondedStake) >= quorum For more information about the governance process and how it works, please check out the Governance module specification . Create a Governance Proposal In order to create a governance proposal, you must submit an initial deposit along with a title and description. Various modules outside of governance may implement their own proposal types and handlers (eg. parameter changes), where the governance module itself supports Text proposals. Any module outside of governance has it's command mounted on top of submit-proposal . To submit a Text proposal: colorcli tx gov submit-proposal \\ --title=<title> \\ --description=<description> \\ --type=\"Text\" \\ --deposit=\"1000000color\" \\ --from=<name> \\ --chain-id=<chain_id> You may also provide the proposal directly through the --proposal flag which points to a JSON file containing the proposal. To submit a parameter change proposal, you must provide a proposal file as its contents are less friendly to CLI input: colorcli tx gov submit-proposal param-change <path/to/proposal.json> \\ --from=<name> \\ --chain-id=<chain_id> Where proposal.json contains the following: { \"title\": \"Param Change\", \"description\": \"Update max validators\", \"changes\": [ { \"subspace\": \"staking\", \"key\": \"MaxValidators\", \"value\": 105 } ], \"deposit\": [ { \"denom\": \"color\", \"amount\": \"10000000\" } ] } ::: danger Warning Currently parameter changes are evaluated but not validated , so it is very important that any value change is valid (ie. correct type and within bounds) for its respective parameter, eg. MaxValidators should be an integer and not a decimal. Proper vetting of a parameter change proposal should prevent this from happening (no deposits should occur during the governance process), but it should be noted regardless. ::: ::: tip Note The SoftwareUpgrade is currently not supported as it's not implemented and currently does not differ from the semantics of a Text proposal. ::: Query Proposals Once created, you can now query information of the proposal: colorcli query gov proposal <proposal_id> Or query all available proposals: colorcli query gov proposals You can also query proposals filtered by voter or depositor by using the corresponding flags. To query for the proposer of a given governance proposal: colorcli query gov proposer <proposal_id> Increase Deposit In order for a proposal to be broadcasted to the network, the amount deposited must be above a minDeposit value (initial value: 512000000color ). If the proposal you previously created didn't meet this requirement, you can still increase the total amount deposited to activate it. Once the minimum deposit is reached, the proposal enters voting period: colorcli tx gov deposit <proposal_id> \"10000000color\" \\ --from=<name> \\ --chain-id=<chain_id> NOTE : Proposals that don't meet this requirement will be deleted after MaxDepositPeriod is reached. Query Deposits Once a new proposal is created, you can query all the deposits submitted to it: colorcli query gov deposits <proposal_id> You can also query a deposit submitted by a specific address: colorcli query gov deposit <proposal_id> <depositor_address> Vote on a Proposal After a proposal's deposit reaches the MinDeposit value, the voting period opens. Bonded color holders can then cast vote on it: colorcli tx gov vote <proposal_id> <Yes/No/NoWithVeto/Abstain> \\ --from=<name> \\ --chain-id=<chain_id> Query Votes Check the vote with the option you just submitted: colorcli query gov vote <proposal_id> <voter_address> You can also get all the previous votes submitted to the proposal with: colorcli query gov votes <proposal_id> Query proposal tally results To check the current tally of a given proposal you can use the tally command: colorcli query gov tally <proposal_id> Query Governance Parameters To check the current governance parameters run: colorcli query gov params To query subsets of the governance parameters run: colorcli query gov param voting colorcli query gov param tallying colorcli query gov param deposit Fee Distribution Query Distribution Parameters To check the current distribution parameters, run: colorcli query distr params Query distribution Community Pool To query all coins in the community pool which is under Governance control: colorcli query distr community-pool Query outstanding rewards To check the current outstanding (un-withdrawn) rewards, run: colorcli query distr outstanding-rewards Query Validator Commission To check the current outstanding commission for a validator, run: colorcli query distr commission <validator_address> Query Validator Slashes To check historical slashes for a validator, run: colorcli query distr slashes <validator_address> <start_height> <end_height> Query Delegator Rewards To check current rewards for a delegation (were they to be withdrawn), run: colorcli query distr rewards <delegator_address> <validator_address> Query All Delegator Rewards To check all current rewards for a delegation (were they to be withdrawn), run: colorcli query distr rewards <delegator_address> Multisig Transactions Multisig transactions require signatures of multiple private keys. Thus, generating and signing a transaction from a multisig account involve cooperation among the parties involved. A multisig transaction can be initiated by any of the key holders, and at least one of them would need to import other parties' public keys into their Keybase and generate a multisig public key in order to finalize and broadcast the transaction. For example, given a multisig key comprising the keys p1 , p2 , and p3 , each of which is held by a distinct party, the user holding p1 would require to import both p2 and p3 in order to generate the multisig account public key: colorcli keys add \\ p2 \\ --pubkey=cosmospub1addwnpepqtd28uwa0yxtwal5223qqr5aqf5y57tc7kk7z8qd4zplrdlk5ez5kdnlrj4 colorcli keys add \\ p3 \\ --pubkey=cosmospub1addwnpepqgj04jpm9wrdml5qnss9kjxkmxzywuklnkj0g3a3f8l5wx9z4ennz84ym5t colorcli keys add \\ p1p2p3 \\ --multisig-threshold=2 \\ --multisig=p1,p2,p3 A new multisig public key p1p2p3 has been stored, and its address will be used as signer of multisig transactions: colorcli keys show --address p1p2p3 You may also view multisig threshold, pubkey constituents and respective weights by viewing the JSON output of the key or passing the --show-multisig flag: colorcli keys show p1p2p3 -o json colorcli keys show p1p2p3 --show-multisig The first step to create a multisig transaction is to initiate it on behalf of the multisig address created above: colorcli tx send cosmos1570v2fq3twt0f0x02vhxpuzc9jc4yl30q2qned 1000000color \\ --from=<multisig_address> \\ --generate-only > unsignedTx.json The file unsignedTx.json contains the unsigned transaction encoded in JSON. p1 can now sign the transaction with its own private key: colorcli tx sign \\ unsignedTx.json \\ --multisig=<multisig_address> \\ --from=p1 \\ --output-document=p1signature.json Once the signature is generated, p1 transmits both unsignedTx.json and p1signature.json to p2 or p3 , which in turn will generate their respective signature: colorcli tx sign \\ unsignedTx.json \\ --multisig=<multisig_address> \\ --from=p2 \\ --output-document=p2signature.json p1p2p3 is a 2-of-3 multisig key, therefore one additional signature is sufficient. Any the key holders can now generate the multisig transaction by combining the required signature files: colorcli tx multisign \\ unsignedTx.json \\ p1p2p3 \\ p1signature.json p2signature.json > signedTx.json The transaction can now be sent to the node: colorcli tx broadcast signedTx.json Shells Completion Scripts Completion scripts for popular UNIX shell interpreters such as Bash and Zsh can be generated through the completion command, which is available for both colord and colorcli . If you want to generate Bash completion scripts run the following command: colord completion > colord_completion colorcli completion > colorcli_completion If you want to generate Zsh completion scripts run the following command: colord completion --zsh > colord_completion colorcli completion --zsh > colorcli_completion ::: tip Note On most UNIX systems, such scripts may be loaded in .bashrc or .bash_profile to enable Bash autocompletion: echo '. colord_completion' >> ~/.bashrc echo '. colorcli_completion' >> ~/.bashrc Refer to the user's manual of your interpreter provided by your operating system for information on how to enable shell autocompletion. :::","title":"ColorCLI"},{"location":"colorcli/#color-client","text":"","title":"Color Client"},{"location":"colorcli/#color-cli","text":"colorcli is the tool that enables you to interact with the node that runs on the Color network, whether you run it yourself or not. Let us set it up properly. In order to install it, follow the installation procedure .","title":"Color CLI"},{"location":"colorcli/#setting-up-colorcli","text":"The main command used to set up colorcli is the following: colorcli config <flag> <value> It allows you to set a default value for each given flag. First, set up the address of the full-node you want to connect to: colorcli config node <host>:<port # example: colorcli config node https://77.87.106.33:26657 If you run your own full-node, just use tcp://localhost:26657 as the address. Then, let us set the default value of the --trust-node flag: colorcli config trust-node true # Set to true if you trust the full-node you are connecting to, false otherwise Finally, let us set the chain-id of the blockchain we want to interact with: colorcli config chain-id <testchain>","title":"Setting up colorcli"},{"location":"colorcli/#keys","text":"","title":"Keys"},{"location":"colorcli/#key-types","text":"There are three types of key representations that are used: cosmos Derived from account keys generated by colorcli keys add Used to receive funds e.g. cosmos15h6vd5f0wqps26zjlwrc6chah08ryu4hzzdwhc cosmosvaloper Used to associate a validator to it's operator Used to invoke staking commands e.g. cosmosvaloper1carzvgq3e6y3z5kz5y6gxp3wpy3qdrv928vyah cosmospub Derived from account keys generated by colorcli keys add e.g. cosmospub1zcjduc3q7fu03jnlu2xpl75s2nkt7krm6grh4cc5aqth73v0zwmea25wj2hsqhlqzm cosmosvalconspub Generated when the node is created with colord init . Get this value with colord tendermint show-validator e.g. cosmosvalconspub1zcjduepq0ms2738680y72v44tfyqm3c9ppduku8fs6sr73fx7m666sjztznqzp2emf","title":"Key Types"},{"location":"colorcli/#generate-keys","text":"You'll need an account private and public key pair (a.k.a. sk, pk respectively) to be able to receive funds, send txs, bond tx, etc. To generate a new secp256k1 key: colorcli keys add <account_name> Next, you will have to create a passphrase to protect the key on disk. The output of the above command will contain a seed phrase . It is recommended to save the seed phrase in a safe place so that in case you forget the password, you could eventually regenerate the key from the seed phrase with the following command: colorcli keys add --recover If you check your private keys, you'll now see <account_name> : colorcli keys show <account_name> View the validator operator's address via: colorcli keys show <account_name> --bech=val You can see all your available keys by typing: colorcli keys list View the validator pubkey for your node by typing: colord tendermint show-validator Note that this is the Tendermint signing key, not the operator key you will use in delegation transactions. ::: danger Warning We strongly recommend NOT using the same passphrase for multiple keys. :::","title":"Generate Keys"},{"location":"colorcli/#generate-multisig-public-keys","text":"You can generate and print a multisig public key by typing: colorcli keys add --multisig=name1,name2,name3[...] --multisig-threshold=K new_key_name K is the minimum number of private keys that must have signed the transactions that carry the public key's address as signer. The --multisig flag must contain the name of public keys that will be combined into a public key that will be generated and stored as new_key_name in the local database. All names supplied through --multisig must already exist in the local database. Unless the flag --nosort is set, the order in which the keys are supplied on the command line does not matter, i.e. the following commands generate two identical keys: colorcli keys add --multisig=foo,bar,baz --multisig-threshold=2 multisig_address colorcli keys add --multisig=baz,foo,bar --multisig-threshold=2 multisig_address Multisig addresses can also be generated on-the-fly and printed through the which command: colorcli keys show --multisig-threshold K name1 name2 name3 [...] For more information regarding how to generate, sign and broadcast transactions with a multi signature account see Multisig Transactions .","title":"Generate Multisig Public Keys"},{"location":"colorcli/#tx-broadcasting","text":"When broadcasting transactions, colorcli accepts a --broadcast-mode flag. This flag can have a value of sync (default), async , or block , where sync makes the client return a CheckTx response, async makes the client return immediately, and block makes the client wait for the tx to be committed (or timing out). It is important to note that the block mode should not be used in most circumstances. This is because broadcasting can timeout but the tx may still be included in a block. This can result in many undesirable situations. Therefor, it is best to use sync or async and query by tx hash to determine when the tx is included in a block.","title":"Tx Broadcasting"},{"location":"colorcli/#fees-gas","text":"Each transaction may either supply fees or gas prices, but not both. Validator's have a minimum gas price (multi-denom) configuration and they use this value when when determining if they should include the transaction in a block during CheckTx , where gasPrices >= minGasPrices . Note, your transaction must supply fees that are greater than or equal to any of the denominations the validator requires. Note : With such a mechanism in place, validators may start to prioritize txs by gasPrice in the mempool, so providing higher fees or gas prices may yield higher tx priority. e.g. colorcli tx send ... --fees=50000color or colorcli tx send ... --gas-prices=0.025color","title":"Fees &amp; Gas"},{"location":"colorcli/#account","text":"","title":"Account"},{"location":"colorcli/#query-account-balance","text":"After receiving tokens to your address, you can view your account's balance by typing: colorcli query account <account_address> ::: warning Note When you query an account balance with zero tokens, you will get this error: No account with address <account_address> was found in the state. This can also happen if you fund the account before your node has fully synced with the chain. These are both normal. :::","title":"Query Account Balance"},{"location":"colorcli/#send-tokens","text":"The following command could be used to send coins from one account to another: colorcli tx send <sender_key_name_or_address> <recipient_address> 10stake \\ --chain-id=<chain_id> ::: warning Note The amount argument accepts the format <value|coin_name> . ::: ::: tip Note You may want to cap the maximum gas that can be consumed by the transaction via the --gas flag. If you pass --gas=auto , the gas supply will be automatically estimated before executing the transaction. Gas estimate might be inaccurate as state changes could occur in between the end of the simulation and the actual execution of a transaction, thus an adjustment is applied on top of the original estimate in order to ensure the transaction is broadcasted successfully. The adjustment can be controlled via the --gas-adjustment flag, whose default value is 1.0. ::: Now, view the updated balances of the origin and destination accounts: colorcli query account <account_address> colorcli query account <destination_address> You can also check your balance at a given block by using the --block flag: colorcli query account <account_address> --block=<block_height> You can simulate a transaction without actually broadcasting it by appending the --dry-run flag to the command line: colorcli tx send <sender_key_name_or_address> <destination_account_address> 10stake \\ --chain-id=<chain_id> \\ --dry-run Furthermore, you can build a transaction and print its JSON format to STDOUT by appending --generate-only to the list of the command line arguments: colorcli tx send <sender_address> <recipient_address> 10stake \\ --chain-id=<chain_id> \\ --generate-only > unsignedSendTx.json colorcli tx sign \\ --chain-id=<chain_id> \\ --from=<key_name> \\ unsignedSendTx.json > signedSendTx.json ::: tip Note The --generate-only flag prevents colorcli from accessing the local keybase. Thus when such flag is supplied <sender_key_name_or_address> must be an address. ::: You can validate the transaction's signatures by typing the following: colorcli tx sign --validate-signatures signedSendTx.json You can broadcast the signed transaction to a node by providing the JSON file to the following command: colorcli tx broadcast --node=<node> signedSendTx.json","title":"Send Tokens"},{"location":"colorcli/#query-transactions","text":"","title":"Query Transactions"},{"location":"colorcli/#matching-a-set-of-tags","text":"You can use the transaction search command to query for transactions that match a specific set of tags , which are added on every transaction. Each tag is conformed by a key-value pair in the form of <tag>:<value> . Tags can also be combined to query for a more specific result using the & symbol. The command for querying transactions using a tag is the following: colorcli query txs --tags='<tag>:<value>' And for using multiple tags : colorcli query txs --tags='<tag1>:<value1>&<tag2>:<value2>' The pagination is supported as well via page and limit : colorcli query txs --tags='<tag>:<value>' --page=1 --limit=20","title":"Matching a Set of Tags"},{"location":"colorcli/#matching-a-transactions-hash","text":"You can also query a single transaction by its hash using the following command: colorcli query tx [hash]","title":"Matching a Transaction's Hash"},{"location":"colorcli/#slashing","text":"","title":"Slashing"},{"location":"colorcli/#unjailing","text":"To unjail your jailed validator colorcli tx slashing unjail --from <validator-operator-addr>","title":"Unjailing"},{"location":"colorcli/#signing-info","text":"To retrieve a validator's signing info: colorcli query slashing signing-info <validator-pubkey>","title":"Signing Info"},{"location":"colorcli/#query-parameters","text":"You can get the current slashing parameters via: colorcli query slashing params","title":"Query Parameters"},{"location":"colorcli/#minting","text":"You can query for the minting/inflation parameters via: colorcli query minting params To query for the current inflation value: colorcli query minting inflation To query for the current annual provisions value: colorcli query minting annual-provisions","title":"Minting"},{"location":"colorcli/#query-validators","text":"You can query the list of all validators of a specific chain: colorcli query staking validators If you want to get the information of a single validator you can check it with: colorcli query staking validator <account_cosmosval>","title":"Query Validators"},{"location":"colorcli/#bond-tokens","text":"colorcli tx staking delegate \\ --amount=10000000stake \\ --validator=<validator> \\ --from=<key_name> \\ --chain-id=<chain_id> <validator> is the operator address of the validator to which you intend to delegate. If you are running a local testnet, you can find this with: colorcli keys show [name] --bech val where [name] is the name of the key you specified when you initialized colord . While tokens are bonded, they are pooled with all the other bonded tokens in the network. Validators and delegators obtain a percentage of shares that equal their stake in this pool.","title":"Bond Tokens"},{"location":"colorcli/#query-delegations","text":"Once submitted a delegation to a validator, you can see it's information by using the following command: colorcli query staking delegation <delegator_addr> <validator_addr> Or if you want to check all your current delegations with disctinct validators: colorcli query staking delegations <delegator_addr>","title":"Query Delegations"},{"location":"colorcli/#unbond-tokens","text":"If for any reason the validator misbehaves, or you just want to unbond a certain amount of tokens, use this following command. colorcli tx staking unbond \\ <validator_addr> \\ 10stake \\ --from=<key_name> \\ --chain-id=<chain_id> The unbonding will be automatically completed when the unbonding period has passed.","title":"Unbond Tokens"},{"location":"colorcli/#query-unbonding-delegations","text":"Once you begin an unbonding-delegation, you can see it's information by using the following command: colorcli query staking unbonding-delegation <delegator_addr> <validator_addr> Or if you want to check all your current unbonding-delegations with disctinct validators: colorcli query staking unbonding-delegations <account_cosmos> Additionally, as you can get all the unbonding-delegations from a particular validator: colorcli query staking unbonding-delegations-from <account_cosmosval>","title":"Query Unbonding-Delegations"},{"location":"colorcli/#redelegate-tokens","text":"A redelegation is a type delegation that allows you to bond illiquid tokens from one validator to another: colorcli tx staking redelegate \\ <src-validator-operator-addr> \\ <dst-validator-operator-addr> \\ 10stake \\ --from=<key_name> \\ --chain-id=<chain_id> Here you can also redelegate a specific shares-amount or a shares-fraction with the corresponding flags. The redelegation will be automatically completed when the unbonding period has passed.","title":"Redelegate Tokens"},{"location":"colorcli/#query-redelegations","text":"Once you begin an redelegation, you can see it's information by using the following command: colorcli query staking redelegation <delegator_addr> <src_val_addr> <dst_val_addr> Or if you want to check all your current unbonding-delegations with distinct validators: colorcli query staking redelegations <account_cosmos> Additionally, as you can get all the outgoing redelegations from a particular validator: colorcli query staking redelegations-from <account_cosmosval>","title":"Query Redelegations"},{"location":"colorcli/#query-parameters_1","text":"Parameters define high level settings for staking. You can get the current values by using: colorcli query staking params With the above command you will get the values for: Unbonding time Maximum numbers of validators Coin denomination for staking All these values will be subject to updates though a governance process by ParameterChange proposals.","title":"Query Parameters"},{"location":"colorcli/#query-pool","text":"A staking Pool defines the dynamic parameters of the current state. You can query them with the following command: colorcli query staking pool With the pool command you will get the values for: Not-bonded and bonded tokens Token supply Current annual inflation and the block in which the last inflation was processed Last recorded bonded shares","title":"Query Pool"},{"location":"colorcli/#query-delegations-to-validator","text":"You can also query all of the delegations to a particular validator: colorcli query delegations-to <account_cosmosval>","title":"Query Delegations To Validator"},{"location":"colorcli/#governance","text":"Governance is the process from which users in the Color Platform can come to consensus on software upgrades, parameters of the mainnet or signaling mechanisms through text proposals. This is done through voting on proposals, which will be submitted by color holders on the mainnet. Some considerations about the voting process: Voting is done by bonded color holders on a 1 bonded color 1 vote basis Delegators inherit the vote of their validator if they don't vote Votes are tallied at the end of the voting period (2 weeks on mainnet) where each address can vote multiple times to update its Option value (paying the transaction fee each time), only the most recently cast vote will count as valid Voters can choose between options Yes , No , NoWithVeto and Abstain At the end of the voting period, a proposal is accepted iff: (YesVotes / (YesVotes+NoVotes+NoWithVetoVotes)) > 1/2 (NoWithVetoVotes / (YesVotes+NoVotes+NoWithVetoVotes)) < 1/3 ((YesVotes+NoVotes+NoWithVetoVotes) / totalBondedStake) >= quorum For more information about the governance process and how it works, please check out the Governance module specification .","title":"Governance"},{"location":"colorcli/#create-a-governance-proposal","text":"In order to create a governance proposal, you must submit an initial deposit along with a title and description. Various modules outside of governance may implement their own proposal types and handlers (eg. parameter changes), where the governance module itself supports Text proposals. Any module outside of governance has it's command mounted on top of submit-proposal . To submit a Text proposal: colorcli tx gov submit-proposal \\ --title=<title> \\ --description=<description> \\ --type=\"Text\" \\ --deposit=\"1000000color\" \\ --from=<name> \\ --chain-id=<chain_id> You may also provide the proposal directly through the --proposal flag which points to a JSON file containing the proposal. To submit a parameter change proposal, you must provide a proposal file as its contents are less friendly to CLI input: colorcli tx gov submit-proposal param-change <path/to/proposal.json> \\ --from=<name> \\ --chain-id=<chain_id> Where proposal.json contains the following: { \"title\": \"Param Change\", \"description\": \"Update max validators\", \"changes\": [ { \"subspace\": \"staking\", \"key\": \"MaxValidators\", \"value\": 105 } ], \"deposit\": [ { \"denom\": \"color\", \"amount\": \"10000000\" } ] } ::: danger Warning Currently parameter changes are evaluated but not validated , so it is very important that any value change is valid (ie. correct type and within bounds) for its respective parameter, eg. MaxValidators should be an integer and not a decimal. Proper vetting of a parameter change proposal should prevent this from happening (no deposits should occur during the governance process), but it should be noted regardless. ::: ::: tip Note The SoftwareUpgrade is currently not supported as it's not implemented and currently does not differ from the semantics of a Text proposal. :::","title":"Create a Governance Proposal"},{"location":"colorcli/#query-proposals","text":"Once created, you can now query information of the proposal: colorcli query gov proposal <proposal_id> Or query all available proposals: colorcli query gov proposals You can also query proposals filtered by voter or depositor by using the corresponding flags. To query for the proposer of a given governance proposal: colorcli query gov proposer <proposal_id>","title":"Query Proposals"},{"location":"colorcli/#increase-deposit","text":"In order for a proposal to be broadcasted to the network, the amount deposited must be above a minDeposit value (initial value: 512000000color ). If the proposal you previously created didn't meet this requirement, you can still increase the total amount deposited to activate it. Once the minimum deposit is reached, the proposal enters voting period: colorcli tx gov deposit <proposal_id> \"10000000color\" \\ --from=<name> \\ --chain-id=<chain_id> NOTE : Proposals that don't meet this requirement will be deleted after MaxDepositPeriod is reached.","title":"Increase Deposit"},{"location":"colorcli/#query-deposits","text":"Once a new proposal is created, you can query all the deposits submitted to it: colorcli query gov deposits <proposal_id> You can also query a deposit submitted by a specific address: colorcli query gov deposit <proposal_id> <depositor_address>","title":"Query Deposits"},{"location":"colorcli/#vote-on-a-proposal","text":"After a proposal's deposit reaches the MinDeposit value, the voting period opens. Bonded color holders can then cast vote on it: colorcli tx gov vote <proposal_id> <Yes/No/NoWithVeto/Abstain> \\ --from=<name> \\ --chain-id=<chain_id>","title":"Vote on a Proposal"},{"location":"colorcli/#query-votes","text":"Check the vote with the option you just submitted: colorcli query gov vote <proposal_id> <voter_address> You can also get all the previous votes submitted to the proposal with: colorcli query gov votes <proposal_id>","title":"Query Votes"},{"location":"colorcli/#query-proposal-tally-results","text":"To check the current tally of a given proposal you can use the tally command: colorcli query gov tally <proposal_id>","title":"Query proposal tally results"},{"location":"colorcli/#query-governance-parameters","text":"To check the current governance parameters run: colorcli query gov params To query subsets of the governance parameters run: colorcli query gov param voting colorcli query gov param tallying colorcli query gov param deposit","title":"Query Governance Parameters"},{"location":"colorcli/#fee-distribution","text":"","title":"Fee Distribution"},{"location":"colorcli/#query-distribution-parameters","text":"To check the current distribution parameters, run: colorcli query distr params","title":"Query Distribution Parameters"},{"location":"colorcli/#query-distribution-community-pool","text":"To query all coins in the community pool which is under Governance control: colorcli query distr community-pool","title":"Query distribution Community Pool"},{"location":"colorcli/#query-outstanding-rewards","text":"To check the current outstanding (un-withdrawn) rewards, run: colorcli query distr outstanding-rewards","title":"Query outstanding rewards"},{"location":"colorcli/#query-validator-commission","text":"To check the current outstanding commission for a validator, run: colorcli query distr commission <validator_address>","title":"Query Validator Commission"},{"location":"colorcli/#query-validator-slashes","text":"To check historical slashes for a validator, run: colorcli query distr slashes <validator_address> <start_height> <end_height>","title":"Query Validator Slashes"},{"location":"colorcli/#query-delegator-rewards","text":"To check current rewards for a delegation (were they to be withdrawn), run: colorcli query distr rewards <delegator_address> <validator_address>","title":"Query Delegator Rewards"},{"location":"colorcli/#query-all-delegator-rewards","text":"To check all current rewards for a delegation (were they to be withdrawn), run: colorcli query distr rewards <delegator_address>","title":"Query All Delegator Rewards"},{"location":"colorcli/#multisig-transactions","text":"Multisig transactions require signatures of multiple private keys. Thus, generating and signing a transaction from a multisig account involve cooperation among the parties involved. A multisig transaction can be initiated by any of the key holders, and at least one of them would need to import other parties' public keys into their Keybase and generate a multisig public key in order to finalize and broadcast the transaction. For example, given a multisig key comprising the keys p1 , p2 , and p3 , each of which is held by a distinct party, the user holding p1 would require to import both p2 and p3 in order to generate the multisig account public key: colorcli keys add \\ p2 \\ --pubkey=cosmospub1addwnpepqtd28uwa0yxtwal5223qqr5aqf5y57tc7kk7z8qd4zplrdlk5ez5kdnlrj4 colorcli keys add \\ p3 \\ --pubkey=cosmospub1addwnpepqgj04jpm9wrdml5qnss9kjxkmxzywuklnkj0g3a3f8l5wx9z4ennz84ym5t colorcli keys add \\ p1p2p3 \\ --multisig-threshold=2 \\ --multisig=p1,p2,p3 A new multisig public key p1p2p3 has been stored, and its address will be used as signer of multisig transactions: colorcli keys show --address p1p2p3 You may also view multisig threshold, pubkey constituents and respective weights by viewing the JSON output of the key or passing the --show-multisig flag: colorcli keys show p1p2p3 -o json colorcli keys show p1p2p3 --show-multisig The first step to create a multisig transaction is to initiate it on behalf of the multisig address created above: colorcli tx send cosmos1570v2fq3twt0f0x02vhxpuzc9jc4yl30q2qned 1000000color \\ --from=<multisig_address> \\ --generate-only > unsignedTx.json The file unsignedTx.json contains the unsigned transaction encoded in JSON. p1 can now sign the transaction with its own private key: colorcli tx sign \\ unsignedTx.json \\ --multisig=<multisig_address> \\ --from=p1 \\ --output-document=p1signature.json Once the signature is generated, p1 transmits both unsignedTx.json and p1signature.json to p2 or p3 , which in turn will generate their respective signature: colorcli tx sign \\ unsignedTx.json \\ --multisig=<multisig_address> \\ --from=p2 \\ --output-document=p2signature.json p1p2p3 is a 2-of-3 multisig key, therefore one additional signature is sufficient. Any the key holders can now generate the multisig transaction by combining the required signature files: colorcli tx multisign \\ unsignedTx.json \\ p1p2p3 \\ p1signature.json p2signature.json > signedTx.json The transaction can now be sent to the node: colorcli tx broadcast signedTx.json","title":"Multisig Transactions"},{"location":"colorcli/#shells-completion-scripts","text":"Completion scripts for popular UNIX shell interpreters such as Bash and Zsh can be generated through the completion command, which is available for both colord and colorcli . If you want to generate Bash completion scripts run the following command: colord completion > colord_completion colorcli completion > colorcli_completion If you want to generate Zsh completion scripts run the following command: colord completion --zsh > colord_completion colorcli completion --zsh > colorcli_completion ::: tip Note On most UNIX systems, such scripts may be loaded in .bashrc or .bash_profile to enable Bash autocompletion: echo '. colord_completion' >> ~/.bashrc echo '. colorcli_completion' >> ~/.bashrc Refer to the user's manual of your interpreter provided by your operating system for information on how to enable shell autocompletion. :::","title":"Shells Completion Scripts"},{"location":"colord/","text":"Single-node, Local, Manual Testnet This guide helps you create a single validator node that runs a network locally for testing and other development related uses. Requirements Install Color Install jq (optional) Create Genesis File and Start the Network # You can run all of these commands from your home directory cd $HOME # Initialize the genesis.json file that will help you to bootstrap the network colord init <moniker name> --chain-id=colorchain # Create a key to hold your validator account colorcli keys add validator # Add that key into the genesis.app_state.accounts array in the genesis file # NOTE: this command lets you set the number of coins. Make sure this account has some coins # with the genesis.app_state.staking.params.bond_denom denom, the default is staking colord add-genesis-account $(colorcli keys show validator -a) 1000000000stake # Generate the transaction that creates your validator colord gentx --name validator # Add the generated bonding transaction to the genesis file colord collect-gentxs # Now its safe to start `colord` colord start This setup puts all the data for colord in ~/.colord . You can examine the genesis file you created at ~/.colord/config/genesis.json . With this configuration colorcli is also ready to use and has an account with tokens (both staking and custom). Multi-node, Local, Automated Testnet From the networks/local directory : Requirements Install color Install docker Install docker-compose Build Build the colord binary (linux) and the tendermint/colornode docker image required for running the localnet commands. This binary will be mounted into the container and can be updated rebuilding the image, so you only need to build the image once. # Work from the SDK repo cd $GOPATH/src/github.com/cosmos/gaia # Build the linux binary in ./build make build-linux # Build tendermint/colordnode image make build-docker-colordnode Run Your Testnet To start a 4 node testnet run: make localnet-start This command creates a 4-node network using the colornode image. The ports for each node are found in this table: Node ID P2P Port RPC Port colordnode0 26656 26657 colordnode1 26659 26660 colordnode2 26661 26662 colordnode3 26663 26664 To update the binary, just rebuild it and restart the nodes: make build-linux localnet-start Configuration The make localnet-start creates files for a 4-node testnet in ./build by calling the colord testnet command. This outputs a handful of files in the ./build directory: $ tree -L 2 build/ build/ \u251c\u2500\u2500 colorcli \u251c\u2500\u2500 colord \u251c\u2500\u2500 gentxs \u2502 \u251c\u2500\u2500 node0.json \u2502 \u251c\u2500\u2500 node1.json \u2502 \u251c\u2500\u2500 node2.json \u2502 \u2514\u2500\u2500 node3.json \u251c\u2500\u2500 node0 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u251c\u2500\u2500 key_seed.json \u2502 \u2502 \u2514\u2500\u2500 keys \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u251c\u2500\u2500 node1 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u2514\u2500\u2500 key_seed.json \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u251c\u2500\u2500 node2 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u2514\u2500\u2500 key_seed.json \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u2514\u2500\u2500 node3 \u251c\u2500\u2500 colorcli \u2502 \u2514\u2500\u2500 key_seed.json \u2514\u2500\u2500 colord \u251c\u2500\u2500 ${LOG:-colord.log} \u251c\u2500\u2500 config \u2514\u2500\u2500 data Each ./build/nodeN directory is mounted to the /colord directory in each container. Logging Logs are saved under each ./build/nodeN/colord/color.log . You can also watch logs directly via Docker, for example: docker logs -f colordnode0 Keys & Accounts To interact with colorcli and start querying state or creating txs, you use the colorcli directory of any given node as your home , for example: colorcli keys list --home ./build/node0/colorcli Now that accounts exists, you may create new accounts and send those accounts funds! ::: tip Note : Each node's seed is located at ./build/nodeN/colorcli/key_seed.json and can be restored to the CLI using the colorcli keys add --restore command ::: Special Binaries If you have multiple binaries with different names, you can specify which one to run with the BINARY environment variable. The path of the binary is relative to the attached volume. For example: # Run with custom binary BINARY=colorfoo make localnet-start","title":"ColorDaemon"},{"location":"colord/#single-node-local-manual-testnet","text":"This guide helps you create a single validator node that runs a network locally for testing and other development related uses.","title":"Single-node, Local, Manual Testnet"},{"location":"colord/#requirements","text":"Install Color Install jq (optional)","title":"Requirements"},{"location":"colord/#create-genesis-file-and-start-the-network","text":"# You can run all of these commands from your home directory cd $HOME # Initialize the genesis.json file that will help you to bootstrap the network colord init <moniker name> --chain-id=colorchain # Create a key to hold your validator account colorcli keys add validator # Add that key into the genesis.app_state.accounts array in the genesis file # NOTE: this command lets you set the number of coins. Make sure this account has some coins # with the genesis.app_state.staking.params.bond_denom denom, the default is staking colord add-genesis-account $(colorcli keys show validator -a) 1000000000stake # Generate the transaction that creates your validator colord gentx --name validator # Add the generated bonding transaction to the genesis file colord collect-gentxs # Now its safe to start `colord` colord start This setup puts all the data for colord in ~/.colord . You can examine the genesis file you created at ~/.colord/config/genesis.json . With this configuration colorcli is also ready to use and has an account with tokens (both staking and custom).","title":"Create Genesis File and Start the Network"},{"location":"colord/#multi-node-local-automated-testnet","text":"From the networks/local directory :","title":"Multi-node, Local, Automated Testnet"},{"location":"colord/#requirements_1","text":"Install color Install docker Install docker-compose","title":"Requirements"},{"location":"colord/#build","text":"Build the colord binary (linux) and the tendermint/colornode docker image required for running the localnet commands. This binary will be mounted into the container and can be updated rebuilding the image, so you only need to build the image once. # Work from the SDK repo cd $GOPATH/src/github.com/cosmos/gaia # Build the linux binary in ./build make build-linux # Build tendermint/colordnode image make build-docker-colordnode","title":"Build"},{"location":"colord/#run-your-testnet","text":"To start a 4 node testnet run: make localnet-start This command creates a 4-node network using the colornode image. The ports for each node are found in this table: Node ID P2P Port RPC Port colordnode0 26656 26657 colordnode1 26659 26660 colordnode2 26661 26662 colordnode3 26663 26664 To update the binary, just rebuild it and restart the nodes: make build-linux localnet-start","title":"Run Your Testnet"},{"location":"colord/#configuration","text":"The make localnet-start creates files for a 4-node testnet in ./build by calling the colord testnet command. This outputs a handful of files in the ./build directory: $ tree -L 2 build/ build/ \u251c\u2500\u2500 colorcli \u251c\u2500\u2500 colord \u251c\u2500\u2500 gentxs \u2502 \u251c\u2500\u2500 node0.json \u2502 \u251c\u2500\u2500 node1.json \u2502 \u251c\u2500\u2500 node2.json \u2502 \u2514\u2500\u2500 node3.json \u251c\u2500\u2500 node0 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u251c\u2500\u2500 key_seed.json \u2502 \u2502 \u2514\u2500\u2500 keys \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u251c\u2500\u2500 node1 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u2514\u2500\u2500 key_seed.json \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u251c\u2500\u2500 node2 \u2502 \u251c\u2500\u2500 colorcli \u2502 \u2502 \u2514\u2500\u2500 key_seed.json \u2502 \u2514\u2500\u2500 colord \u2502 \u251c\u2500\u2500 ${LOG:-colord.log} \u2502 \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 data \u2514\u2500\u2500 node3 \u251c\u2500\u2500 colorcli \u2502 \u2514\u2500\u2500 key_seed.json \u2514\u2500\u2500 colord \u251c\u2500\u2500 ${LOG:-colord.log} \u251c\u2500\u2500 config \u2514\u2500\u2500 data Each ./build/nodeN directory is mounted to the /colord directory in each container.","title":"Configuration"},{"location":"colord/#logging","text":"Logs are saved under each ./build/nodeN/colord/color.log . You can also watch logs directly via Docker, for example: docker logs -f colordnode0","title":"Logging"},{"location":"colord/#keys-accounts","text":"To interact with colorcli and start querying state or creating txs, you use the colorcli directory of any given node as your home , for example: colorcli keys list --home ./build/node0/colorcli Now that accounts exists, you may create new accounts and send those accounts funds! ::: tip Note : Each node's seed is located at ./build/nodeN/colorcli/key_seed.json and can be restored to the CLI using the colorcli keys add --restore command :::","title":"Keys &amp; Accounts"},{"location":"colord/#special-binaries","text":"If you have multiple binaries with different names, you can specify which one to run with the BINARY environment variable. The path of the binary is relative to the attached volume. For example: # Run with custom binary BINARY=colorfoo make localnet-start","title":"Special Binaries"},{"location":"faucet/","text":"Color Testnet Faucet This faucet app allows anyone who passes a captcha to request tokens for a Color account address. This app needs to be deployed on a Color testnet full node, because it relies on using the colorcli command to send tokens. Prerequisites reCAPTCHA If you don't have a reCAPTCHA site setup for the faucet, now is the time to get one. Go to the Google reCAPTCHA Admin and create a new reCAPTCHA site. For the version of captcha, choose reCAPTCHA v2 . Checkout Code The backend requires Go and the dep dependency tool to be installed. For the frontend, you also need to have node.js and the yarn dependency tool installed. go get git@github.com:color/faucet Backend Setup Production First, set the environment variables for the backend, using ./backend/.env as a template: cd $GOPATH/src/github.com/color/faucet/backend cp .env .env.local vi .env.local Then build the backend. dep ensure go build faucet.go The following executable will run the faucet on port 8080. ./faucet WARNING : It's highly recommended to run a reverse proxy with rate limiting in front of this app. Included in this repo is an example Caddyfile that lets you run an TLS secured faucet that is rate limited to 1 claim per IP per day. Development Run go run faucet,.go in the backend directory to serve the backend. Frontend Setup Production First, set the environment variables for the frontend, using ./frontend/.env as a template: cd $GOPATH/src/github.com/color/faucet/frontend cp .env .env.local vi .env.local Then build the frontend. yarn yarn build Lastly, serve the ./frontend/dist directory with the web server of your choice. Development Run yarn serve in the frontend directory to serve the frontend with hot reload.","title":"Faucet"},{"location":"faucet/#color-testnet-faucet","text":"This faucet app allows anyone who passes a captcha to request tokens for a Color account address. This app needs to be deployed on a Color testnet full node, because it relies on using the colorcli command to send tokens.","title":"Color Testnet Faucet"},{"location":"faucet/#prerequisites","text":"","title":"Prerequisites"},{"location":"faucet/#recaptcha","text":"If you don't have a reCAPTCHA site setup for the faucet, now is the time to get one. Go to the Google reCAPTCHA Admin and create a new reCAPTCHA site. For the version of captcha, choose reCAPTCHA v2 .","title":"reCAPTCHA"},{"location":"faucet/#checkout-code","text":"The backend requires Go and the dep dependency tool to be installed. For the frontend, you also need to have node.js and the yarn dependency tool installed. go get git@github.com:color/faucet","title":"Checkout Code"},{"location":"faucet/#backend-setup","text":"","title":"Backend Setup"},{"location":"faucet/#production","text":"First, set the environment variables for the backend, using ./backend/.env as a template: cd $GOPATH/src/github.com/color/faucet/backend cp .env .env.local vi .env.local Then build the backend. dep ensure go build faucet.go The following executable will run the faucet on port 8080. ./faucet WARNING : It's highly recommended to run a reverse proxy with rate limiting in front of this app. Included in this repo is an example Caddyfile that lets you run an TLS secured faucet that is rate limited to 1 claim per IP per day.","title":"Production"},{"location":"faucet/#development","text":"Run go run faucet,.go in the backend directory to serve the backend.","title":"Development"},{"location":"faucet/#frontend-setup","text":"","title":"Frontend Setup"},{"location":"faucet/#production_1","text":"First, set the environment variables for the frontend, using ./frontend/.env as a template: cd $GOPATH/src/github.com/color/faucet/frontend cp .env .env.local vi .env.local Then build the frontend. yarn yarn build Lastly, serve the ./frontend/dist directory with the web server of your choice.","title":"Production"},{"location":"faucet/#development_1","text":"Run yarn serve in the frontend directory to serve the frontend with hot reload.","title":"Development"},{"location":"joinTestNet/","text":"Join color-testnet Public Testnet color-test-1001 is now live! The genesis files are in ./latest We have airdropped testnet tokens to all participants in the last Cosmos Hub testnet. If you would like to participate and have not received tokens, you can get some from this faucet. How to Run a Testnet Validator Please refer to the Color Hub documentation on validators for a general overview of running a validator. We are using the exact same validator model and software, but with slightly different parameters and other functionality specific to Color Network. Prerequisites $ sudo apt-get install gcc g++ Install GO $ wget https://raw.githubusercontent.com/jim380/node_tooling/master/Cosmos/CLI/go_install.sh $ chmod +x go_install.sh $ ./go_install.sh -v 1.12.5 At the time of this writing, 1.12.5 is the latest version of Golang. Go 1.12+ is required for the Color SDK. Install COLOR $ mkdir -p $GOPATH/src/github.com/color $ cd $GOPATH/src/github.com/color $ git clone -b <latest-release-tag> https://github.com/color-network/color-ledger $ cd color-ledger $ make install Find the latest release tags here . To verify if installation was successful: $ colord version --long $ colorcli version --long Setting Up a New Node $ colord init --chain-id=color-test-1001 <your_moniker> $ colorcli keys add <your_wallet_name> ## Make sure you back up the mnemonics !!! Creating a Validator If you are joining at genesis scroll down to the section on Creating a Genesis Validator! Please follow the documentation provided on creating a validator for Cosmos hub , replacing gaiad and gaiacli with colord and colorcli respectively. Also our testnet staking token denomination is color and Color addresses begin with color: instead of cosmos . Creating a Genesis Validator This section applies ONLY if you are joining at genesis! Genesis for Color Test-1001 was in June 2019 Generate Genesis Transaction (optional) $ colord add-genesis-account $(colorcli keys show <your_wallet_name> -a) 1000000color,1000000validatortoken $ colord gentx --name <your_wallet_name> --amount 1000000color If all goes well, you will see the following message: Genesis transaction written to \"/home/user/.colord/config/gentx/gentx-f8038a89034kl987ebd493b85a125624d5f4770.json\" Submit Gentx (optional) Submit your gentx in a PR here Genesis & Seeds Fetch genesis.json into colord 's config directory. $ curl https://raw.githubusercontent.com/color-network/testnets/master/color-test-1001/genesis.json > $HOME/.colord/config/genesis.json Add seed nodes in config.toml . $ nano $HOME/.colord/config/config.toml Find the following section and add the seed nodes. # Comma separated list of seed nodes to connect to seeds = \"\" Make colord a System Service (optional) $ sudo nano /lib/systemd/system/colord.service Paste in the following: [Unit] Description=Color Xrnd After=network-online.target [Service] User=<your_user> ExecStart=/home/<your_user>/go_workspace/bin/colord start StandardOutput=file:/var/log/colord/colord.log StandardError=file:/var/log/colord/colord_error.log Restart=always RestartSec=3 LimitNOFILE=4096 [Install] WantedBy=multi-user.target This tutorial assumes $HOME/go_workspace to be your Go workspace. Your actual workspace directory may vary. Start Node Method 1 - With systemd $ sudo systemctl enable colord $ sudo systemctl start colord Check node status $ colorcli status Check logs $ sudo journalctl -u colord -f Method 2 - Without systemd $ colord start Check node status $ colorcli status Create Validator To create validator you must have colors coin in you account then perform the following transaction To get the public key for create validator the the following commnad colord tendermint show-validator Now run the following command colorcli tx staking create-validator --amount=1000000tree --pubkey=xrn:valconspub1zcjduepqay6ynhexeev7me09gfx5dhr82yp4furnyyrvyhff42dl5j04f7lsrzvpn2 --moniker=rnssol-moniker --chain-id=regen-test-1001 --commission-rate=\"0.10\" --commission-max-rate=\"0.20\" --commission-max-change-rate=\"0.01\" --min-self-delegation=\"1\" --gas=\"auto\" --gas-prices=\"0.2color\" --fees=2color --from=rnssol After this the validator will be shown on your blockchain explorer.","title":"JoinTestNet"},{"location":"joinTestNet/#join-color-testnet-public-testnet","text":"color-test-1001 is now live! The genesis files are in ./latest We have airdropped testnet tokens to all participants in the last Cosmos Hub testnet. If you would like to participate and have not received tokens, you can get some from this faucet.","title":"Join color-testnet Public Testnet"},{"location":"joinTestNet/#how-to-run-a-testnet-validator","text":"Please refer to the Color Hub documentation on validators for a general overview of running a validator. We are using the exact same validator model and software, but with slightly different parameters and other functionality specific to Color Network.","title":"How to Run a Testnet Validator"},{"location":"joinTestNet/#prerequisites","text":"$ sudo apt-get install gcc g++","title":"Prerequisites"},{"location":"joinTestNet/#install-go","text":"$ wget https://raw.githubusercontent.com/jim380/node_tooling/master/Cosmos/CLI/go_install.sh $ chmod +x go_install.sh $ ./go_install.sh -v 1.12.5 At the time of this writing, 1.12.5 is the latest version of Golang. Go 1.12+ is required for the Color SDK.","title":"Install GO"},{"location":"joinTestNet/#install-color","text":"$ mkdir -p $GOPATH/src/github.com/color $ cd $GOPATH/src/github.com/color $ git clone -b <latest-release-tag> https://github.com/color-network/color-ledger $ cd color-ledger $ make install Find the latest release tags here . To verify if installation was successful: $ colord version --long $ colorcli version --long","title":"Install COLOR"},{"location":"joinTestNet/#setting-up-a-new-node","text":"$ colord init --chain-id=color-test-1001 <your_moniker> $ colorcli keys add <your_wallet_name> ## Make sure you back up the mnemonics !!!","title":"Setting Up a New Node"},{"location":"joinTestNet/#creating-a-validator","text":"If you are joining at genesis scroll down to the section on Creating a Genesis Validator! Please follow the documentation provided on creating a validator for Cosmos hub , replacing gaiad and gaiacli with colord and colorcli respectively. Also our testnet staking token denomination is color and Color addresses begin with color: instead of cosmos .","title":"Creating a Validator"},{"location":"joinTestNet/#creating-a-genesis-validator","text":"This section applies ONLY if you are joining at genesis! Genesis for Color Test-1001 was in June 2019","title":"Creating a Genesis Validator"},{"location":"joinTestNet/#generate-genesis-transaction-optional","text":"$ colord add-genesis-account $(colorcli keys show <your_wallet_name> -a) 1000000color,1000000validatortoken $ colord gentx --name <your_wallet_name> --amount 1000000color If all goes well, you will see the following message: Genesis transaction written to \"/home/user/.colord/config/gentx/gentx-f8038a89034kl987ebd493b85a125624d5f4770.json\"","title":"Generate Genesis Transaction (optional)"},{"location":"joinTestNet/#submit-gentx-optional","text":"Submit your gentx in a PR here","title":"Submit Gentx (optional)"},{"location":"joinTestNet/#genesis-seeds","text":"Fetch genesis.json into colord 's config directory. $ curl https://raw.githubusercontent.com/color-network/testnets/master/color-test-1001/genesis.json > $HOME/.colord/config/genesis.json Add seed nodes in config.toml . $ nano $HOME/.colord/config/config.toml Find the following section and add the seed nodes. # Comma separated list of seed nodes to connect to seeds = \"\"","title":"Genesis &amp; Seeds"},{"location":"joinTestNet/#make-colord-a-system-service-optional","text":"$ sudo nano /lib/systemd/system/colord.service Paste in the following: [Unit] Description=Color Xrnd After=network-online.target [Service] User=<your_user> ExecStart=/home/<your_user>/go_workspace/bin/colord start StandardOutput=file:/var/log/colord/colord.log StandardError=file:/var/log/colord/colord_error.log Restart=always RestartSec=3 LimitNOFILE=4096 [Install] WantedBy=multi-user.target This tutorial assumes $HOME/go_workspace to be your Go workspace. Your actual workspace directory may vary.","title":"Make colord a System Service (optional)"},{"location":"joinTestNet/#start-node","text":"Method 1 - With systemd $ sudo systemctl enable colord $ sudo systemctl start colord Check node status $ colorcli status Check logs $ sudo journalctl -u colord -f Method 2 - Without systemd $ colord start Check node status $ colorcli status","title":"Start Node"},{"location":"joinTestNet/#create-validator","text":"To create validator you must have colors coin in you account then perform the following transaction To get the public key for create validator the the following commnad colord tendermint show-validator Now run the following command colorcli tx staking create-validator --amount=1000000tree --pubkey=xrn:valconspub1zcjduepqay6ynhexeev7me09gfx5dhr82yp4furnyyrvyhff42dl5j04f7lsrzvpn2 --moniker=rnssol-moniker --chain-id=regen-test-1001 --commission-rate=\"0.10\" --commission-max-rate=\"0.20\" --commission-max-change-rate=\"0.01\" --min-self-delegation=\"1\" --gas=\"auto\" --gas-prices=\"0.2color\" --fees=2color --from=rnssol After this the validator will be shown on your blockchain explorer.","title":"Create Validator"},{"location":"ledger-colors/","text":"Tendermint/Colors Apps for Ledger Nano S Get source Apart from cloning, be sure you get all the submodules, by calling: git submodule update --init --recursive Dependencies Ledger Nano S This project requires ledger firmware 1.5.5 The current repository keeps track of Ledger's SDK but it is posible to override it by changing the git submodule. CircleCI CLI CircleCI allows compiling BOLOS firmware both in Linux and MacOS. The CLI will download a docker container ready to run. To install, follow the instructions here: https://circleci.com/docs/2.0/local-cli/#installing-the-circleci-local-cli-on-macos-and-linux-distros Docker CE CircleCI CLI should have instructed you to install Docker. Just in case, you can find instructions here too: https://docs.docker.com/install/ Ubuntu Dependencies Install the following packages: sudo apt-get update && sudo apt-get -y install build-essential git sudo wget cmake libssl-dev libgmp-dev autoconf libtool python-pip OSX Dependencies It is recommended that you install brew and xcode. Additionally you will need to: brew install libusb Ledger Python Tools Ledger firmware 1.5.5 requires ledgerblue >= 0.1.21. In most cases, make deps should be able to install all dependencies: make deps Building There are different local builds: Generic C++ code and run unit tests BOLOS firmware Generic C++ Code / Tests This is useful when you want to make changes to libraries, run unit tests, etc. It will build all common libraries and unit tests. Compile cmake . && make In Case Above Command didn't work, use the command given below. It will compile local code but it will not try to crosscompile the apps. Typically this is more efficient too. cmake -DDISABLE_DOCKER_BUILDS=ON . && make Run unit tests export GTEST_COLOR=1 && ctest -VV BOLOS / Ledger firmware In order to keep builds reproducible, a Makefile is provided. The Makefile will build the firmware in a docker container and leave the binary in the correct directory. Build The following command will build the app firmware inside a container. All output will be available to the host. make # Builds both Colors and Tendermint apps Upload the app to the device The following command will upload the application to the ledger. Warning: The application will be deleted before uploading. make load_cosmos # Loads Cosmos app (for users) make load_tendermint # Loads Tendermint app (for validators) Continuous Integration (debugging CI issues) This will build in a docker image identical to what CircleCI uses. This provides a clean, reproducible environment. It also can be helpful to debug CI issues. To build in ubuntu 16.04 and run C++ unit tests circleci build To build BOLOS firmware circleci build --job build_ledger_user circleci build --job build_ledger_val","title":"Ledger Nano Color App Setup"},{"location":"ledger-colors/#tendermintcolors-apps-for-ledger-nano-s","text":"","title":"Tendermint/Colors Apps for Ledger Nano S"},{"location":"ledger-colors/#get-source","text":"Apart from cloning, be sure you get all the submodules, by calling: git submodule update --init --recursive","title":"Get source"},{"location":"ledger-colors/#dependencies","text":"","title":"Dependencies"},{"location":"ledger-colors/#ledger-nano-s","text":"This project requires ledger firmware 1.5.5 The current repository keeps track of Ledger's SDK but it is posible to override it by changing the git submodule.","title":"Ledger Nano S"},{"location":"ledger-colors/#circleci-cli","text":"CircleCI allows compiling BOLOS firmware both in Linux and MacOS. The CLI will download a docker container ready to run. To install, follow the instructions here: https://circleci.com/docs/2.0/local-cli/#installing-the-circleci-local-cli-on-macos-and-linux-distros","title":"CircleCI CLI"},{"location":"ledger-colors/#docker-ce","text":"CircleCI CLI should have instructed you to install Docker. Just in case, you can find instructions here too: https://docs.docker.com/install/","title":"Docker CE"},{"location":"ledger-colors/#ubuntu-dependencies","text":"Install the following packages: sudo apt-get update && sudo apt-get -y install build-essential git sudo wget cmake libssl-dev libgmp-dev autoconf libtool python-pip","title":"Ubuntu Dependencies"},{"location":"ledger-colors/#osx-dependencies","text":"It is recommended that you install brew and xcode. Additionally you will need to: brew install libusb","title":"OSX Dependencies"},{"location":"ledger-colors/#ledger-python-tools","text":"Ledger firmware 1.5.5 requires ledgerblue >= 0.1.21. In most cases, make deps should be able to install all dependencies: make deps","title":"Ledger Python Tools"},{"location":"ledger-colors/#building","text":"There are different local builds: Generic C++ code and run unit tests BOLOS firmware","title":"Building"},{"location":"ledger-colors/#generic-c-code-tests","text":"This is useful when you want to make changes to libraries, run unit tests, etc. It will build all common libraries and unit tests. Compile cmake . && make In Case Above Command didn't work, use the command given below. It will compile local code but it will not try to crosscompile the apps. Typically this is more efficient too. cmake -DDISABLE_DOCKER_BUILDS=ON . && make Run unit tests export GTEST_COLOR=1 && ctest -VV","title":"Generic C++ Code / Tests"},{"location":"ledger-colors/#bolos-ledger-firmware","text":"In order to keep builds reproducible, a Makefile is provided. The Makefile will build the firmware in a docker container and leave the binary in the correct directory. Build The following command will build the app firmware inside a container. All output will be available to the host. make # Builds both Colors and Tendermint apps Upload the app to the device The following command will upload the application to the ledger. Warning: The application will be deleted before uploading. make load_cosmos # Loads Cosmos app (for users) make load_tendermint # Loads Tendermint app (for validators)","title":"BOLOS / Ledger firmware"},{"location":"ledger-colors/#continuous-integration-debugging-ci-issues","text":"This will build in a docker image identical to what CircleCI uses. This provides a clean, reproducible environment. It also can be helpful to debug CI issues. To build in ubuntu 16.04 and run C++ unit tests circleci build To build BOLOS firmware circleci build --job build_ledger_user circleci build --job build_ledger_val","title":"Continuous Integration (debugging CI issues)"},{"location":"ledgersetup/","text":"Ledger Nano integration Ledger Nano is a hardware device that allows user to send and recieve transaction using this hardware wallet. To work with color testnet ledgner nano should be connected with light client to process transactions. Requirments Install ledger live Install ledger Nano Backend Setup After installing ledger nano live , if it is your new device initialize it as a new device and follow the 5 steps in ledger live menu . if the process get stuck at : connect and unlock your ledger device navigate through your dashboard follow these commands to configure leger with ledger live 1. setup Check if the plugdev group exists by entering the command: cat /etc/group | grep plugdev Check if the plugdev group exists by entering the command: cat /etc/group | grep plugdev Follow the steps below if the previous command did not return a result Create the plugdev group: sudo groupadd plugdev Check if you are in the group plugdev with the command: group If the output does not contain plugdev, you are not in the plugdev group. Enter the command: sudo gpasswd -a <user> plugdev Note: replace <user> by your username, e.g for user \"mike\", it would be: sudo gpasswd -a mike plugdev. Logout and login for the change to take effect. To verify you are now in the plugdev group, enter: groups and search for a plugdev occurrence. If it's not there, you've missed a step and should restart from step 1. 2. Add the udev rules Enter the following command to automatically add the rules and reload udev: wget -q -O - https://raw.githubusercontent.com/LedgerHQ/udev-rules/master/add_udev_rules.sh | sudo bash Retry connecting your Ledger Nano S with Ledger Live. If it's still not working, continue to step 3 3.Troubleshooting. Try each of the following three options. Option 1 Edit the file /etc/udev/rules.d/20-hw1.rules file by adding the OWNER=\"<user>\" parameter to each line, where <user> is your Linux user name. Then reload the rules as follows: udevadm trigger udevadm control --reload-rules Retry the connection with Ledger Live. If it does not work, try the next option. Option 2 Edit the /etc/udev/rules.d/20-hw1.rules file and add the following lines: KERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0660\", GROUP=\"plugdev\", ATTRS{idVendor}==\"2c97\" KERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0660\", GROUP=\"plugdev\", ATTRS{idVendor}==\"2581\" Then reload the rules: udevadm trigger udevadm control --reload-rules Retry connecting with Ledger Live. If it does not work yet, try the last option. Option 3 If you are on Arch Linux, you can try the following rules: /etc/udev/rules.d/20-hw1.rules SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"2b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"3b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"4b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1807\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1808\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0000\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0001\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\u201d SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0004\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" Then reload the rules again and retry the connection with Ledger Live: udevadm trigger udevadm control --reload-rules Still not working after following all the steps correctly? Please contact ledger support . After that Allow ledger manager on your device by pressing right button on ledger. This will open ledger live dashborad for you Install Cosmos App Follow these steps to install cosoms app on your device. - unlock your device by providing pin - go to settings on top right corner an select Experimental Features - check on developer mode - got to manager in ledger live left navigation bar search for cosmos - install updated version by clicking install button - this will install cosoms app on your ledger device Frontend Setup Connect your colors with wallet server, and follow these steps Sign in using ledger nano: To sign in using ledger nano you will have to: unlock ledger device by entering pin code open cosmos app in ledger device else you cannnot sign in . After sucessfull signin you will see your dashbord open wallet in left naviagtion bar in wallet server fill out the form for transaction sender address amount and gas sign the transaction using ledger device by pressing right button on ledger on sign transaction option. you have sucessfully sent a valid transaction.","title":"Ledger Nano Setup"},{"location":"ledgersetup/#ledger-nano-integration","text":"Ledger Nano is a hardware device that allows user to send and recieve transaction using this hardware wallet. To work with color testnet ledgner nano should be connected with light client to process transactions.","title":"Ledger Nano integration"},{"location":"ledgersetup/#requirments","text":"Install ledger live Install ledger Nano","title":"Requirments"},{"location":"ledgersetup/#backend-setup","text":"After installing ledger nano live , if it is your new device initialize it as a new device and follow the 5 steps in ledger live menu .","title":"Backend Setup"},{"location":"ledgersetup/#if-the-process-get-stuck-at","text":"connect and unlock your ledger device navigate through your dashboard follow these commands to configure leger with ledger live","title":"if the process get stuck at :"},{"location":"ledgersetup/#1-setup","text":"Check if the plugdev group exists by entering the command: cat /etc/group | grep plugdev Check if the plugdev group exists by entering the command: cat /etc/group | grep plugdev","title":"1. setup"},{"location":"ledgersetup/#follow-the-steps-below-if-the-previous-command-did-not-return-a-result","text":"Create the plugdev group: sudo groupadd plugdev Check if you are in the group plugdev with the command: group If the output does not contain plugdev, you are not in the plugdev group. Enter the command: sudo gpasswd -a <user> plugdev","title":"Follow the steps below if the previous command did not return a result"},{"location":"ledgersetup/#note-replace-ltusergt-by-your-username-eg-for-user-mike-it-would-be-sudo-gpasswd-a-mike-plugdev","text":"Logout and login for the change to take effect. To verify you are now in the plugdev group, enter: groups and search for a plugdev occurrence. If it's not there, you've missed a step and should restart from step 1.","title":"Note: replace &lt;user&gt; by your username, e.g for user \"mike\", it would be: sudo gpasswd -a mike plugdev."},{"location":"ledgersetup/#2-add-the-udev-rules","text":"Enter the following command to automatically add the rules and reload udev: wget -q -O - https://raw.githubusercontent.com/LedgerHQ/udev-rules/master/add_udev_rules.sh | sudo bash Retry connecting your Ledger Nano S with Ledger Live.","title":"2. Add the udev rules"},{"location":"ledgersetup/#if-its-still-not-working-continue-to-step-3","text":"","title":"If it's still not working, continue to step 3"},{"location":"ledgersetup/#3troubleshooting","text":"Try each of the following three options.","title":"3.Troubleshooting."},{"location":"ledgersetup/#option-1","text":"Edit the file /etc/udev/rules.d/20-hw1.rules file by adding the OWNER=\"<user>\" parameter to each line, where <user> is your Linux user name. Then reload the rules as follows: udevadm trigger udevadm control --reload-rules Retry the connection with Ledger Live. If it does not work, try the next option.","title":"Option 1"},{"location":"ledgersetup/#option-2","text":"Edit the /etc/udev/rules.d/20-hw1.rules file and add the following lines: KERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0660\", GROUP=\"plugdev\", ATTRS{idVendor}==\"2c97\" KERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0660\", GROUP=\"plugdev\", ATTRS{idVendor}==\"2581\" Then reload the rules: udevadm trigger udevadm control --reload-rules Retry connecting with Ledger Live. If it does not work yet, try the last option.","title":"Option 2"},{"location":"ledgersetup/#option-3","text":"If you are on Arch Linux, you can try the following rules: /etc/udev/rules.d/20-hw1.rules SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"2b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"3b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"4b7c\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1807\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2581\", ATTRS{idProduct}==\"1808\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0000\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0001\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\u201d SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"2c97\", ATTRS{idProduct}==\"0004\", MODE=\"0660\", TAG+=\"uaccess\", TAG+=\"udev-acl\" Then reload the rules again and retry the connection with Ledger Live: udevadm trigger udevadm control --reload-rules Still not working after following all the steps correctly? Please contact ledger support .","title":"Option 3"},{"location":"ledgersetup/#after-that","text":"Allow ledger manager on your device by pressing right button on ledger. This will open ledger live dashborad for you","title":"After that"},{"location":"ledgersetup/#install-cosmos-app","text":"Follow these steps to install cosoms app on your device. - unlock your device by providing pin - go to settings on top right corner an select Experimental Features - check on developer mode - got to manager in ledger live left navigation bar search for cosmos - install updated version by clicking install button - this will install cosoms app on your ledger device","title":"Install Cosmos App"},{"location":"ledgersetup/#frontend-setup","text":"Connect your colors with wallet server, and follow these steps","title":"Frontend  Setup"},{"location":"ledgersetup/#sign-in-using-ledger-nano","text":"To sign in using ledger nano you will have to: unlock ledger device by entering pin code open cosmos app in ledger device else you cannnot sign in . After sucessfull signin you will see your dashbord open wallet in left naviagtion bar in wallet server fill out the form for transaction sender address amount and gas sign the transaction using ledger device by pressing right button on ledger on sign transaction option. you have sucessfully sent a valid transaction.","title":"Sign in using ledger nano:"},{"location":"setup-kops/","text":"Up a Kubernetes Cluster on AWS in 5 Minutes Kubernetes is like magic. It is a system for working with containerized applications: deployment, scaling, management, service discovery, magic. Think Docker at scale with little hassle. Despite the power of Kubernetes though, I find the official guide for setting up Kubernetes on AWS a bit overwhelming, so I wrote a simpler version to get started. As a side note, AWS introduced a new serviced called A mazon Elastic Container Service for Kubernetes \u2013 EKS for short. But it\u2019s still in Preview mode. Before we begin, here\u2019s a YouTube video demonstrating how to set up a Kubernetes Cluster on AWS following the instructions below: Prerequisites Before setting up the Kubernetes cluster, you\u2019ll need an AWS account and an installation of the AWS Command Line Interface . Make sure to configure the AWS CLI to use your access key ID and secret access key: aws configure AWS Access Key ID [None]: your aws access key AWS Secret Access Key [None]: your aws secret key Default region name [None]: us-east-1 Default output format [None]: Installing kops + kubectl Now, to get started, let\u2019s install two Kubernetes CLI utilities: Kubernetes Operations, kops Kubernetes command-line tool, kubectl On Mac OS X, we\u2019ll use brew to install. If you\u2019re on Linux, see the official Kops installation guide. Setting Up the Kubernetes Cluster Easy enough. Now, let\u2019s set up the Kubernetes cluster. The first thing we need to do is create an S3 bucket for kops to use to store the state of the Kubernetes cluster and its configuration. We\u2019ll use the bucket name colors-kops-state-store. $ aws s3api create-bucket --bucket colors-kops-state-store --region us-east-2 --create-bucket-configuration LocationConstraint=us-east-2 After creating the colors-kops-state-store bucket, let\u2019s enable versioning to revert or recover a previous state store. $ aws s3api put-bucket-versioning --bucket colors-kops-state-store --versioning-configuration Status=Enabled Before creating the cluster, let\u2019s set two environment variables: KOPS_CLUSTER_NAME and KOPS_STATE_STORE. For safe keeping you should add the following to your ~/.bash_profile or ~/.bashrc configs (or whatever the equivalent is if you don\u2019t use bash). export KOPS_CLUSTER_NAME=colors.k8s.local export KOPS_STATE_STORE=s3://colors-kops-state-store kops export kubecfg --state s3://colors-kops-state-store --name=colors.k8s.local You don\u2019t HAVE TO set the environment variables, but they are useful and referenced by kops commands. For example, see kops create cluster --help . If the the Kubernetes cluster name ends with k8s.local, Kubernetes will create a gossip-based cluster. Now, to generate the cluster configuration: $ kops create cluster --node-count=1 --node-size=t2.medium --zones=us-east-2b Note: this line doesn\u2019t launch the AWS EC2 instances. It simply creates the configuration and writes to the s3://colors-kops-state-store bucket we created above. In our example, we\u2019re creating 2 t2.medium EC2 work nodes in addition to a c4.large master instance (default). $ kops edit cluster Alternatively, you can name the cluster by appending --name to the command: $ kops create cluster --node-count=1 --node-size=t2.medium --zones=us-east-1a --name chubby-bunnies Now that we\u2019ve generated a cluster configuration, we can edit its description before launching the instances. The config is loaded from s3://colors-kops-state-store. You can change the editor used to edit the config by setting $EDITOR or $KUBE_EDITOR. For instance, in my ~/.bashrc, I have export KUBE_EDITOR=emacs. Time to build the cluster. This takes a few minutes to boot the EC2 instances and download the Kubernetes components. kops update cluster --name ${KOPS_CLUSTER_NAME} --yes After waiting a bit, let\u2019s validate the cluster to ensure the master + 2 nodes have launched. $ kops validate cluster Validating cluster colors.k8s.local INSTANCE GROUPS NAME ROLE MACHINETYPE MIN MAX SUBNETS master-us-east-1a Master c4.large 1 1 us-east-1a nodes Node t2.medium 2 2 us-east-1a NODE STATUS NAME ROLE READY ip-172-20-34-111.ec2.internal node True ip-172-20-40-24.ec2.internal master True ip-172-20-62-139.ec2.internal node True Note: If you ignore the message Cluster is starting. It should be ready in a few minutes. and validate too early, you\u2019ll get an error. Wait a little longer for the nodes to launch, and the validate step will return without error. $ kops validate cluster Validating cluster colors.k8s.local unexpected error during validation: error listing nodes: Get https://api-colors-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/api/v1/nodes: EOF Finally, you can see your Kubernetes nodes with kubectl: $ kubectl get nodes NAME STATUS ROLES AGE VERSION ip-172-20-34-111.ec2.internal Ready node 2h v1.9.3 ip-172-20-40-24.ec2.internal Ready master 2h v1.9.3 ip-172-20-62-139.ec2.internal Ready node 2h v1.9.3 Kubernetes Dashboard Excellent. We have a working Kubernetes cluster deployed on AWS. At this point, we can deploy lots of things, such as Dask and Jupyter. For demonstration, we\u2019ll launch the Kubernetes Dashboard. Think UI instead of command line for managing Kubernetes clusters and applications. Here\u2019s a YouTube video illustrating how to install the Kubernetes Dashboard: kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml secret \"kubernetes-dashboard-certs\" created serviceaccount \"kubernetes-dashboard\" created role.rbac.authorization.k8s.io \"kubernetes-dashboard-minimal\" created rolebinding.rbac.authorization.k8s.io \"kubernetes-dashboard-minimal\" created deployment.apps \"kubernetes-dashboard\" created service \"kubernetes-dashboard\" created You can see that various items were created, including the kubernetes-dashboard service and app. If the dashboard was created, how do we view it? Easy. Let\u2019s get the AWS hostname: $ kubectl cluster-info Kubernetes master is running at https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com KubeDNS is running at https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. With this hostname, open your browser to https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/ui. (You\u2019ll need to replace the hostname with yours). Alternatively, you can access the Dashboard UI via a proxy: kubectl proxy Starting to serve on 127.0.0.1:8001 https://api-colors-k8s-local-inoltk-1851277883.us-east-2.elb.amazonaws.com/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login login password nyY0Wm0ocm63cea1TnkA9G0cZkD3vEkd admin token XPjiuCWjRGM7ScVbmIoWtUU3ljsHnt04 Adding team member is kubernetes project https://itnext.io/let-you-team-members-use-kubernetes-bf2ebd0be717 helmins() { kubectl -n kube-system create serviceaccount tiller kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller helm init --service-account=tiller } helmdel() { kubectl -n kube-system delete deployment tiller-deploy kubectl delete clusterrolebinding tiller kubectl -n kube-system delete serviceaccount tiller } kubectl port-forward nonexistent-labradoodle-colors-helm-7cf6d7f88d-66dh5 8080:80 to get passs kops get secrets kube --type secret -oplaintext to get token kops get secrets admin --type secret -oplaintext","title":"Up a Kubernetes Cluster on AWS in 5 Minutes"},{"location":"setup-kops/#up-a-kubernetes-cluster-on-aws-in-5-minutes","text":"Kubernetes is like magic. It is a system for working with containerized applications: deployment, scaling, management, service discovery, magic. Think Docker at scale with little hassle. Despite the power of Kubernetes though, I find the official guide for setting up Kubernetes on AWS a bit overwhelming, so I wrote a simpler version to get started. As a side note, AWS introduced a new serviced called A mazon Elastic Container Service for Kubernetes \u2013 EKS for short. But it\u2019s still in Preview mode. Before we begin, here\u2019s a YouTube video demonstrating how to set up a Kubernetes Cluster on AWS following the instructions below:","title":"Up a Kubernetes Cluster on AWS in 5 Minutes"},{"location":"setup-kops/#prerequisites","text":"Before setting up the Kubernetes cluster, you\u2019ll need an AWS account and an installation of the AWS Command Line Interface . Make sure to configure the AWS CLI to use your access key ID and secret access key: aws configure AWS Access Key ID [None]: your aws access key AWS Secret Access Key [None]: your aws secret key Default region name [None]: us-east-1 Default output format [None]: Installing kops + kubectl Now, to get started, let\u2019s install two Kubernetes CLI utilities: Kubernetes Operations, kops Kubernetes command-line tool, kubectl On Mac OS X, we\u2019ll use brew to install. If you\u2019re on Linux, see the official Kops installation guide.","title":"Prerequisites"},{"location":"setup-kops/#setting-up-the-kubernetes-cluster","text":"Easy enough. Now, let\u2019s set up the Kubernetes cluster. The first thing we need to do is create an S3 bucket for kops to use to store the state of the Kubernetes cluster and its configuration. We\u2019ll use the bucket name colors-kops-state-store. $ aws s3api create-bucket --bucket colors-kops-state-store --region us-east-2 --create-bucket-configuration LocationConstraint=us-east-2 After creating the colors-kops-state-store bucket, let\u2019s enable versioning to revert or recover a previous state store. $ aws s3api put-bucket-versioning --bucket colors-kops-state-store --versioning-configuration Status=Enabled Before creating the cluster, let\u2019s set two environment variables: KOPS_CLUSTER_NAME and KOPS_STATE_STORE. For safe keeping you should add the following to your ~/.bash_profile or ~/.bashrc configs (or whatever the equivalent is if you don\u2019t use bash). export KOPS_CLUSTER_NAME=colors.k8s.local export KOPS_STATE_STORE=s3://colors-kops-state-store kops export kubecfg --state s3://colors-kops-state-store --name=colors.k8s.local You don\u2019t HAVE TO set the environment variables, but they are useful and referenced by kops commands. For example, see kops create cluster --help . If the the Kubernetes cluster name ends with k8s.local, Kubernetes will create a gossip-based cluster. Now, to generate the cluster configuration: $ kops create cluster --node-count=1 --node-size=t2.medium --zones=us-east-2b Note: this line doesn\u2019t launch the AWS EC2 instances. It simply creates the configuration and writes to the s3://colors-kops-state-store bucket we created above. In our example, we\u2019re creating 2 t2.medium EC2 work nodes in addition to a c4.large master instance (default). $ kops edit cluster Alternatively, you can name the cluster by appending --name to the command: $ kops create cluster --node-count=1 --node-size=t2.medium --zones=us-east-1a --name chubby-bunnies Now that we\u2019ve generated a cluster configuration, we can edit its description before launching the instances. The config is loaded from s3://colors-kops-state-store. You can change the editor used to edit the config by setting $EDITOR or $KUBE_EDITOR. For instance, in my ~/.bashrc, I have export KUBE_EDITOR=emacs. Time to build the cluster. This takes a few minutes to boot the EC2 instances and download the Kubernetes components. kops update cluster --name ${KOPS_CLUSTER_NAME} --yes After waiting a bit, let\u2019s validate the cluster to ensure the master + 2 nodes have launched. $ kops validate cluster Validating cluster colors.k8s.local INSTANCE GROUPS NAME ROLE MACHINETYPE MIN MAX SUBNETS master-us-east-1a Master c4.large 1 1 us-east-1a nodes Node t2.medium 2 2 us-east-1a NODE STATUS NAME ROLE READY ip-172-20-34-111.ec2.internal node True ip-172-20-40-24.ec2.internal master True ip-172-20-62-139.ec2.internal node True Note: If you ignore the message Cluster is starting. It should be ready in a few minutes. and validate too early, you\u2019ll get an error. Wait a little longer for the nodes to launch, and the validate step will return without error. $ kops validate cluster Validating cluster colors.k8s.local unexpected error during validation: error listing nodes: Get https://api-colors-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/api/v1/nodes: EOF Finally, you can see your Kubernetes nodes with kubectl: $ kubectl get nodes NAME STATUS ROLES AGE VERSION ip-172-20-34-111.ec2.internal Ready node 2h v1.9.3 ip-172-20-40-24.ec2.internal Ready master 2h v1.9.3 ip-172-20-62-139.ec2.internal Ready node 2h v1.9.3","title":"Setting Up the Kubernetes Cluster"},{"location":"setup-kops/#kubernetes-dashboard","text":"Excellent. We have a working Kubernetes cluster deployed on AWS. At this point, we can deploy lots of things, such as Dask and Jupyter. For demonstration, we\u2019ll launch the Kubernetes Dashboard. Think UI instead of command line for managing Kubernetes clusters and applications. Here\u2019s a YouTube video illustrating how to install the Kubernetes Dashboard: kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml secret \"kubernetes-dashboard-certs\" created serviceaccount \"kubernetes-dashboard\" created role.rbac.authorization.k8s.io \"kubernetes-dashboard-minimal\" created rolebinding.rbac.authorization.k8s.io \"kubernetes-dashboard-minimal\" created deployment.apps \"kubernetes-dashboard\" created service \"kubernetes-dashboard\" created You can see that various items were created, including the kubernetes-dashboard service and app. If the dashboard was created, how do we view it? Easy. Let\u2019s get the AWS hostname: $ kubectl cluster-info Kubernetes master is running at https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com KubeDNS is running at https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. With this hostname, open your browser to https://api-ramhiser-k8s-local-71cb48-202595039.us-east-1.elb.amazonaws.com/ui. (You\u2019ll need to replace the hostname with yours). Alternatively, you can access the Dashboard UI via a proxy: kubectl proxy Starting to serve on 127.0.0.1:8001 https://api-colors-k8s-local-inoltk-1851277883.us-east-2.elb.amazonaws.com/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/login login password nyY0Wm0ocm63cea1TnkA9G0cZkD3vEkd admin token XPjiuCWjRGM7ScVbmIoWtUU3ljsHnt04","title":"Kubernetes Dashboard"},{"location":"setup-kops/#adding-team-member-is-kubernetes-project","text":"https://itnext.io/let-you-team-members-use-kubernetes-bf2ebd0be717 helmins() { kubectl -n kube-system create serviceaccount tiller kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller helm init --service-account=tiller } helmdel() { kubectl -n kube-system delete deployment tiller-deploy kubectl delete clusterrolebinding tiller kubectl -n kube-system delete serviceaccount tiller } kubectl port-forward nonexistent-labradoodle-colors-helm-7cf6d7f88d-66dh5 8080:80 to get passs kops get secrets kube --type secret -oplaintext to get token kops get secrets admin --type secret -oplaintext","title":"Adding team member is kubernetes project"}]}